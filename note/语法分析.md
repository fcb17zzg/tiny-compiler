# 第 2 章 语法分析 (Parsing) 阅读笔记

语法分析是解释器的第二个核心阶段，它接收词法分析器输出的**词法单元（token）**流，并将其转换为一种结构化的表示形式，即**抽象语法树 (AST) **。

## 2.1 抽象语法树（AST）

AST 是源代码的内部表示形式，是语法分析器的最终输出。

- **抽象性：** AST 之所以是“抽象”的，是因为它省略了源代码中不影响语义的细节，例如空格、分号、花括号、方括号和括号等，这些仅用于指导语法分析器构造结构。

- 节点结构：

   Monkey 语言的 AST 主要由两种类型的节点构成：

  语句 (Statement)和 表达式 (Expression)。

  - 每个节点都必须实现 `Node` 接口，该接口包含 `TokenLiteral()` 和 `String()` 方法。
  - `Program` 节点是 AST 的根节点，它包含一个 `Statement` 节点的切片。

- **语句与表达式的区别：** 表达式会产生值，而语句（如 `let x = 5;`）本身通常不会产生值。Monkey 语言中的大多数构造，包括函数字面量和条件语句，都被设计为表达式。

## 2.2 语法分析策略：普拉特解析法

Monkey 解释器的语法分析器采用**递归下降**策略，具体来说是基于**自上而下的运算符优先级分析法（Top Down Operator Precedence）**，也称为 **普拉特语法分析器 (Pratt Parser)**。

### 普拉特解析的核心概念

普拉特解析法不将解析功能与语法规则关联，而是将解析函数与**单个词法单元类型**关联。

1. 解析函数类型:

    每个词法单元类型最多可以关联两个解析函数：

   - **前缀解析函数 (`prefixParseFn`)：** 也称为 NUD (null denotations)。在词法单元位于**前缀位置**时调用（例如，`-5` 中的 `-`）。
   - **中缀解析函数 (`infixParseFn`)：** 也称为 LED (left denotations)。在词法单元位于**中缀位置**时调用，它接收左侧已解析的表达式作为参数。

2. **优先级（Precedence）：** 运算符优先级通过一系列递增的整数常量定义，例如 `LOWEST`, `EQUALS`, `SUM`, `PRODUCT`, `PREFIX`, `CALL` 和 **`INDEX`**。这些优先级决定了运算符的运算顺序和结合性。

### 普拉特解析的工作机制

普拉特解析器通过比较当前表达式的**右约束能力（Right Binding Power）**和下一个运算符的**左约束能力（Left Binding Power）**来正确地嵌套表达式。

- `parseExpression` 函数接收一个 `precedence` 参数，这个值代表当前表达式的**右约束能力**。
- 循环会不断尝试解析中缀表达式，条件是下一个运算符（`p.peekToken`）的优先级（即左约束能力，通过 `p.peekPrecedence()` 获取）必须**大于**当前的右约束能力。
- 如果下一个运算符的优先级更高，则当前的左表达式（`leftExp`）将被“融合”到下一个中缀表达式中，作为其左操作数。

## 2.3 语句的解析

Monkey 语言只有两种基本语句类型：`let` 语句和 `return` 语句。

### 1. 变量绑定 (`let` 语句)

- 用于将值绑定到给定名称上，结构为 `let <标识符> = <表达式>;`。
- 对应的 AST 节点为 `LetStatement`。
- 解析流程涉及检查 `let` 关键字，期望紧随其后的是标识符 (`IDENT`) 和赋值符号 (`ASSIGN`)。

### 2. 返回语句 (`return` 语句)

- 用于从函数中返回值，结构为 `return <表达式>;`。
- 对应的 AST 节点为 `ReturnStatement`。

### 3. 表达式语句 (`ExpressionStatement`)

- 用于封装仅由表达式构成的语句（如 `5 + 5;`）。
- `Parser` 在遇到不是 `let` 或 `return` 的词法单元时，默认尝试解析 `ExpressionStatement`。
- 分号在 `ExpressionStatement` 中是**可选的**，以便于在 REPL 中输入代码。

## 2.4 表达式的解析与扩展

### 核心表达式

| 表达式类型     | 词法单元               | 普拉特角色             | 优先级                        | 机制/AST 节点                                                |
| -------------- | ---------------------- | ---------------------- | ----------------------------- | ------------------------------------------------------------ |
| **标识符**     | `IDENT`                | 前缀 (`prefixParseFn`) | N/A                           | `Identifier`，简单返回其字面量。                             |
| **整数字面量** | `INT`                  | 前缀 (`prefixParseFn`) | N/A                           | `IntegerLiteral`，将字面量转换为 `int64`。                   |
| **前缀表达式** | `!`, `-`               | 前缀 (`prefixParseFn`) | `PREFIX`                      | `PrefixExpression`，用于一元运算，如 `-5`, `!true`。         |
| **中缀表达式** | `+`, `*`, `==`, `<` 等 | 中缀 (`infixParseFn`)  | `SUM`, `PRODUCT`, `EQUALS` 等 | `InfixExpression`，用于二元运算，优先级由查找表 `precedences` 决定。 |
| **布尔字面量** | `true`, `false`        | 前缀 (`prefixParseFn`) | N/A                           | `Boolean`。                                                  |

### 复杂表达式的解析

1. **分组表达式：** 用于改变优先级，结构为 `( <表达式> )`。
   - 通过为左括号 `(` 注册前缀解析函数 `parseGroupedExpression` 实现。
   - 该函数递归调用 `p.parseExpression(LOWEST)`，将内部表达式作为最高优先级处理，从而正确地嵌套和分组表达式。
2. **If 表达式：** 是一个可以产生值的表达式，结构为 `if (<条件>) { <结果> } else { <可替代结果> }`。
   - 对应的 AST 节点是 `IfExpression`，它包含 `Condition`（表达式）、`Consequence`（语句块）和可选的 `Alternative`（语句块）。
   - 语句块通过 `BlockStatement` 节点表示，其中可以包含一系列 `Statement`。
3. **函数字面量 (`fn`)：** 结构为 `fn(<参数列表>) { <块语句> }`。
   - 对应的 AST 节点为 `FunctionLiteral`。
   - 参数列表的解析与调用表达式的参数列表类似，使用 `parseFunctionParameters` 处理。
4. **调用表达式：** 结构为 `<表达式>(<以逗号分隔的表达式列表>)`。
   - **关键机制：** 将左括号 `(` 视为**中缀运算符**，为其注册 `infixParseFn` (`parseCallExpression`)。
   - 它具有最高优先级 `CALL`，确保函数名称（左操作数）首先被解析，然后参数列表才被解析。

## 2.5 RPPL (Read-Parse-Print Loop)

在完成语法分析器后，测试环境从 RLPL（读取-词法分析-打印）升级为 **RPPL**（读取-语法分析-打印循环）。

RPPL 接收源代码输入，经过词法分析和语法分析后，通过调用 AST 根节点 (`Program`) 的 `String()` 方法将解析后、结构化表示的 AST 打印到终端，用于验证解析结果和运算符优先级是否正确。