## 第 1 章 词法分析 (Lexical Analysis)

词法分析是解释器处理源代码的第一步，目的是将源代码转换为更容易访问的形式。词法分析器（有时也称词法单元生成器或扫描器）将源代码转换为**词法单元 (token)**。随后，语法分析器会将这些词法单元转换为抽象语法树（AST）。

### 1.1 词法分析

**词法分析**是将源代码（如纯文本）转换为一系列词法单元的过程。

#### 词法单元 (Token) 的特点

• 词法单元是短小、易于分类的数据结构。

• 每个词法单元都包含**类型 (Type)** 和**字面量 (Literal)** 两个核心属性,。

• 字面量是词法单元对应的源代码表示形式（例如，`+` 对应的字面量是 `+`）。对于标识符或整数，字面量还会携带具体值（例如，整数 `5` 对应的词法单元会携带数值 `5`，而不是字符串 `"5"`）。

#### 空白字符的处理

在 Monkey 语言中，空白字符（空格、制表符、换行符、回车符）不会被识别成词法单元,。它们的长度不影响代码含义，仅作为其他词法单元的**分隔符**，因此词法分析器可以直接跳过这些字符,,。

### 1.2 定义词法单元

定义词法单元是编写词法分析器的第一步。

#### 词法单元分类

Monkey 语言的词法单元主要分为以下几类，这些分类基于对源代码（如 `let five = 5;`）的分析:

1. **数字 (Numbers):** 如 `5` 和 `10`，统一处理为整数类型（`INT`）,。
2. **标识符 (Identifiers):** 如变量名 `x`, `y`, `add` 等，统一用作 `IDENT`,。
3. **关键字 (Keywords):** 看起来像标识符但具有特殊含义的词，如 `let` 和 `fn`,。
4. **特殊字符 (Special Characters):** 如 `(`, `)`, `{`, `}`, `=`, `,`, `;` 等，每个特殊字符都会有单独的类型,.

#### Token 结构体定义

词法单元通过 `Token` 结构定义，其中 `TokenType` 被定义为字符串类型，有助于调试,。

| 类型名称    | 描述                                                     |
| ----------- | -------------------------------------------------------- |
| `TokenType` | 字符串类型，用于区分词法单元类型。                       |
| `Token`     | 包含 `Type` (`TokenType`) 和 `Literal` (`string`) 字段。 |

初始定义的常量包括：

• **特殊类型:** **ILLEGAL**（表示遇到未知字符或词法单元）和 **EOF**（表示文件结尾，通知语法分析器停机）,。

• **字面量:** `IDENT`, `INT`。

• **运算符:** `ASSIGN` (`=`), `PLUS` (`+`)。

• **分隔符:** `COMMA` (`,`), `SEMICOLON` (`;`), `LPAREN` (`(`), `RPAREN` (`)`), `LBRACE` (`{`), `RBRACE` (`}`)。

• **关键字:** `FUNCTION` (`fn`), `LET` (`let`).

### 1.3 词法分析器

词法分析器 (Lexer) 将源代码作为输入，通过重复调用 `NextToken()` 方法逐个输出识别出的词法单元。

#### Lexer 结构体

`Lexer` 结构体包含用于遍历输入字符串的字段:

• `input`: 接收的源代码字符串。

• `position`: **当前位置**，指向正在查看的字符。

• `readPosition`: **当前读取位置**，指向当前字符之后的**下一个**字符，用于“查看”后续字符,。

• `ch`: 当前正在查看的字符（字节类型 `byte`）。

#### 核心辅助方法

1. **readChar()**:

  ◦ 读取 `input` 中的下一个字符，并将 `l.ch` 更新为该字符。

  ◦ 如果到达输入末尾，将 `l.ch` 设置为 `0` (NUL 字符)。

  ◦ 前移 `position` 和 `readPosition`.

  ◦ *注意：* 当前实现仅支持 ASCII 字符。

2. **skipWhitespace()**:

  ◦ 用于跳过空白字符（空格, `\t`, `\n`, `\r`）.

3. **readIdentifier()** **/** **isLetter()**:

  ◦ `isLetter` 判断字符是否为字母（a-z, A-Z）或下划线 (`_`)。

  ◦ `readIdentifier` 用于读取完整的标识符或关键字，直到遇到非字母字符为止.

  ◦ 读取完成后，使用 `LookupIdent` 检查其是否为预定义的**关键字**（如 `let`），否则归类为普通 **IDENT**.

4. **readNumber()** **/** **isDigit()**:

  ◦ `isDigit` 判断字符是否为数字（`0` 到 `9`）.

  ◦ `readNumber` 读取完整的数字，并将其作为 **INT** 词法单元的字面量.

### 1.4 扩展词法单元和词法分析器

#### 处理多字符运算符

对于需要向前看一个字符才能确定的双字符词法单元（如 `==`, `!=`），需要 `peekChar()` 方法.

• **peekChar()**: 返回 `l.readPosition` 处的字符，但不推进 `position` 或 `readPosition`，允许“窥视”输入中的下一个字符,.

在 `NextToken()` 中，当遇到可能构成多字符词法单元的字符（如 `=` 或 `!`）时，词法分析器会调用 `peekChar()` 来决定是返回单字符词法单元 (`ASSIGN`, `BANG`) 还是双字符词法单元 (`EQ`, `NOT_EQ`),.

#### 新增关键字

新增的关键字，如 `true`, `false`, `if`, `else`, `return` 等，被添加到 `LookupIdent` 的关键字映射表中,.

### 1.5 编写 REPL

REPL（Read-Eval-Print Loop，读取–求值–打印循环）是用于测试词法分析器的环境。在仅有词法分析器时，它充当 **RLPL** (Read-Lex-Print Loop)。

REPL 的实现会从标准输入读取一行代码，实例化 `Lexer`，然后重复调用 `NextToken()` 直到遇到 `EOF`，并打印出生成的词法单元信息,.